generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Evento {
  id        Int      @id @default(autoincrement())
  nombre    String
  fecha     DateTime
  estado    String   @default("activo") // activo, archivado
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  comites   Comite[]
}

model Comite {
  id        Int      @id @default(autoincrement())
  nombre    String
  eventoId  Int
  evento    Evento   @relation(fields: [eventoId], references: [id])
  
  asignacionesMesa AsignacionMesa[]
  delegados        Delegado[]
  asignacionesHoja AsignacionHoja[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// MANY-TO-MANY: UsuarioMesa ↔ Comite (with position)
model AsignacionMesa {
  id            Int         @id @default(autoincrement())
  usuarioMesaId Int
  comiteId      Int
  cargo         String      // e.g., "Presidente", "Vicepresidente", "Moderador"
  
  usuarioMesa   UsuarioMesa @relation(fields: [usuarioMesaId], references: [id])
  comite        Comite      @relation(fields: [comiteId], references: [id])
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  @@unique([usuarioMesaId, comiteId])
}

model UsuarioMesa {
  id               Int              @id @default(autoincrement())
  nombre           String
  usuario          String           @unique
  contrasena       String
  activo           Boolean          @default(true)
  asignaciones     AsignacionMesa[]
  usuariosPermisos UsuarioPermiso[]
  
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
}

enum TipoPermiso {
  PAGINA
  ACCION
}

model Permiso {
  id               Int              @id @default(autoincrement())
  clave            String           @unique
  nombre           String
  descripcion      String?
  tipo             TipoPermiso
  usuariosPermisos UsuarioPermiso[]
  
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
}

model UsuarioPermiso {
  id            Int         @id @default(autoincrement())
  usuarioMesaId Int
  permisoId     Int
  
  usuarioMesa   UsuarioMesa @relation(fields: [usuarioMesaId], references: [id], onDelete: Cascade)
  permiso       Permiso     @relation(fields: [permisoId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime    @default(now())
  
  @@unique([usuarioMesaId, permisoId])
}

model Pais {
  id         Int        @id @default(autoincrement())
  nombre     String     @unique
  codigo     String     // ISO code for flags
  banderaUrl String?    // URL to flag image
  activo     Boolean    @default(true)
  delegados  Delegado[]
}

model Delegado {
  id        Int      @id @default(autoincrement())
  nombre    String
  email     String?
  paisId    Int
  pais      Pais     @relation(fields: [paisId], references: [id])
  comiteId  Int
  comite    Comite   @relation(fields: [comiteId], references: [id])
  activo    Boolean  @default(true)
  
  puntajes        Puntaje[]
  
  // Restored fields
  telefono        String?
  edad            Int?
  grado           String?          // 1ro, 2do, 3ro, 4to, 5to, 6to
  centroEducativoId Int?
  centroEducativo CentroEducativo? @relation(fields: [centroEducativoId], references: [id])
  
  participanteId  Int?
  participante    Participante?    @relation(fields: [participanteId], references: [id])

  // New fields for grading
  participaciones Int      @default(0)
  comentarios     String?  @db.Text

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model Participante {
  id              Int      @id @default(autoincrement())
  nombre          String
  email           String?  @unique
  telefono        String?
  fechaNacimiento DateTime?
  grado           String?
  
  centroEducativoId Int?
  centroEducativo CentroEducativo? @relation(fields: [centroEducativoId], references: [id])
  
  delegaciones    Delegado[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model CentroEducativo {
  id        Int        @id @default(autoincrement())
  nombre    String     @unique
  activo    Boolean    @default(true)
  delegados Delegado[]
  participantes Participante[]
  
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

// Evaluation Sheets are now REUSABLE (not tied to single committee)
model HojaEvaluacion {
  id               Int              @id @default(autoincrement())
  nombre           String
  descripcion      String?
  criterios        Criterio[]
  asignacionesHoja AsignacionHoja[] // M:N with Committee
  
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
}

// MANY-TO-MANY: HojaEvaluacion ↔ Comite
model AsignacionHoja {
  id       Int            @id @default(autoincrement())
  comiteId Int
  hojaId   Int
  
  comite   Comite         @relation(fields: [comiteId], references: [id])
  hoja     HojaEvaluacion @relation(fields: [hojaId], references: [id])
  
  createdAt DateTime      @default(now())
  
  @@unique([comiteId, hojaId])
}

model Criterio {
  id         Int            @id @default(autoincrement())
  nombre     String
  maxPuntaje Int
  hojaId     Int
  hoja       HojaEvaluacion @relation(fields: [hojaId], references: [id])
  puntajes   Puntaje[]
}

model Puntaje {
  id         Int      @id @default(autoincrement())
  valor      Int
  delegadoId Int
  delegado   Delegado @relation(fields: [delegadoId], references: [id])
  criterioId Int
  criterio   Criterio @relation(fields: [criterioId], references: [id])
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([delegadoId, criterioId])
}

model GradingPresence {
  id         Int      @id @default(autoincrement())
  delegadoId Int
  criterioId Int
  userId     String   // ID or name of the user editing
  updatedAt  DateTime @updatedAt

  @@unique([delegadoId, criterioId]) // Only one person can edit a cell at a time? Or just track last editor?
  // Let's allow multiple presence records but we'll upsert by user+cell if we want to track multiple people on same cell.
  // For simplicity and "locking" UI, let's assume we just want to know "who is here".
  // If we want to show "User A is editing", we upsert by (delegadoId, criterioId).
  // Actually, if User A and User B are both there, we might want to know both?
  // But the requirement is "if someone is editing".
  // Let's stick to one active editor per cell for simplicity of the "lock" visualization.
}
